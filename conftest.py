"""
PyTest configuration and fixtures for API Automation POC
"""
import pytest
import requests
from unittest.mock import Mock, patch
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Test configuration
BASE_URL = os.getenv("API_BASE_URL", "https://api.hanwha-vision.com")
API_KEY = os.getenv("API_KEY", "test_api_key_12345")
USERNAME = os.getenv("USERNAME", "test_user")
PASSWORD = os.getenv("PASSWORD", "test_password")

@pytest.fixture(scope="session")
def base_url():
    """Base URL for API endpoints"""
    return BASE_URL

@pytest.fixture(scope="session")
def auth_token():
    """Authentication token for API requests"""
    # Mock authentication - in real scenario, this would call auth endpoint
    return {
        "access_token": "mock_access_token_12345",
        "token_type": "Bearer",
        "expires_in": 3600
    }

@pytest.fixture(scope="session")
def api_headers(auth_token):
    """Default headers for API requests"""
    return {
        "Authorization": f"Bearer {auth_token['access_token']}",
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-API-Key": API_KEY
    }

@pytest.fixture(scope="session")
def db_connection_mock():
    """Mock database connection for testing"""
    mock_db = Mock()
    mock_db.execute.return_value = Mock()
    mock_db.fetchone.return_value = {"id": 1, "name": "Test User"}
    mock_db.fetchall.return_value = [
        {"id": 1, "name": "User 1"},
        {"id": 2, "name": "User 2"}
    ]
    return mock_db

@pytest.fixture
def mock_response():
    """Mock response object for testing"""
    mock_resp = Mock(spec=requests.Response)
    mock_resp.status_code = 200
    mock_resp.json.return_value = {"message": "Success"}
    mock_resp.headers = {"Content-Type": "application/json"}
    return mock_resp

@pytest.fixture
def test_user_data():
    """Sample user data for testing"""
    return {
        "username": "testuser",
        "email": "test@example.com",
        "first_name": "Test",
        "last_name": "User",
        "role": "user"
    }

@pytest.fixture
def invalid_user_data():
    """Invalid user data for negative testing"""
    return {
        "username": "testuser"
        # Missing required fields: email, first_name, last_name
    }

@pytest.fixture(scope="session")
def schemathesis_config():
    """Configuration for Schemathesis testing"""
    return {
        "base_url": BASE_URL,
        "headers": {
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json"
        },
        "checks": ["not_a_server_error", "status_code_conformance", "content_type_conformance"],
        "max_response_time": 5000,  # 5 seconds
        "hypothesis_settings": {
            "max_examples": 10,
            "deadline": 5000
        }
    }

# Custom markers for test categorization
def pytest_configure(config):
    """Configure custom markers"""
    config.addinivalue_line("markers", "slow: marks tests as slow")
    config.addinivalue_line("markers", "integration: marks tests as integration tests")
    config.addinivalue_line("markers", "security: marks tests as security tests")
    config.addinivalue_line("markers", "schemathesis: marks tests as auto-generated by schemathesis")

# Performance tracking
@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    """Track test execution time for metrics"""
    outcome = yield
    report = outcome.get_result()
    
    if report.when == "call":
        # Store execution time for metrics
        report.duration = call.duration
        report.latency_p50 = call.duration  # Simplified - in real scenario would calculate percentiles
        report.latency_p95 = call.duration * 1.5  # Mock P95 calculation
